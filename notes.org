* Links
- https://github.com/patriciogonzalezvivo/glslViewer
- https://github.com/Hodapp87/cs6460_project
- https://hodapp87.github.io/cs6460_project/
- Inigo Quilez's slides and demo
  - [[http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf][Rendering Worlds with Two Triangles]]
- Book of Shaders
- Open Shading Language
- https://github.com/quephird/nail-polish-bot ?
- http://nuclear.mutantstargoat.com/articles/sdr_fract/
- http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/
* TODO High-level slides
* TODO Implementations
* TODO See if glslViewer works on my laptop
* TODO If glslViewer works, what outputs do I need for CincyFP?
* TODO Could I do this in a Pi?
  - Fast enough?
  - Can I show the GLSL framebuffer and code at the same time?
  - Can I show slides?  (Need GUI probably)
    - Couldn't do speaker notes most likely
* TODO At least one 2D fractal and one DE 3D fractal
* Misc notes
- Scanline rendering
- Raytracing to sphere tracing, both as a way to produce shapes from
  functions
  - CSG as a specific version of the above
- Path tracing (shading vs. rendering - they are independent)
- Why Perlin noise matters
  - RenderMan
- Shader languages are "functional" in some vague sense
  - They sort of have to be because of running in parallel
- Sphere tracing / DE
  - What meaningful 'functional' operations?
- With procedural textures, shaders, shapes, and graphics in general
  we can represent a lot of content of a scene not as "data" but as
  functions, and representing as functions brings many benefits
  (such as opening it up to certain transformations and compositions
  otherwise not possible or not easy)
- Graphics are sort of where I started with FP in the first place.
  Used PolyRay & POV-Ray around 1999-2000, picked up POV-Ray again in
  2004, made a lot of use of its ability to model things with
  functions.  Tried to learn Lisp because I was interested in using
  its macros to compile what were basically shaders to run more
  quickly.  Learned Scala to mess around with some algorithmic art; it
  led me to Haskell.
  - I wrote things in C & SDL back in 2003-2004, and gravitated
    towards writing things basically as shaders.  I remember working
    on some similar things in early 2007 and I ran into the problem
    that a CPU simply could not push pixels to the framebuffer fast
    enough to do what I needed in real-time.  An interesting thing
    happened sometime after: every computer, phone, and tablet started
    shipping with fast hardware support for the exact kind of
    computation I needed.
- Perlin's paper and RenderMan shaders were in some sense a practical
  solution to contemporary limitations on size, space, and compute
  power.  Their "functional" basis is what made them effective.
- Realtime & offline shading languages emerged from different
  contexts, but both with very similar (functional) semantics.
* Limits
- Don't try to live-code a sphere tracer.
- Don't explain too much about ray-tracers.
- Keep global illumination to a minimum.
- Don't let little tangents distract you now.  Get the basic structure
  and go from there.
* Old stuff to show
- Dazzle? Acid Warp?
- SDL Acidity?
- POV-Ray renders?
- Old Python Acidity stuff?
